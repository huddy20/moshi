# Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнил(а):
- Холкин Данил Алексеевич
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию init (), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
class Danil:
        __slots__ = ['name']

        def __init__(self, name):
            if name == 'Данил':
                self.name = f"Да, я {name}"
            else:
                self.name = f"Я не {name}, а Данил"


person1 = Danil('Алексей')
person2 = Danil('Данил')
print(person1.name)
print(person2.name)

person2.surname = 'Холкин'
```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/1t9.png)

## Выводы
Создание класса с одним свойством. Создание функции init(). Проверка, что будет если указать несществующий атрибут класса.

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в которой будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python
class Icecream:
        def __init__(self, ingredient=None):
            if isinstance(ingredient, str):
                self.ingredient = ingredient
            else:
                self.ingredient = None

        def composition(self):
            if self.ingredient:
                print(f"Мороженое с {self.ingredient}")
            else:
                print('Обычное мороженое')


icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/2t9.png)

## Выводы
Создание класса Icecream с методом, который выводит на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». Программа воспринимает только атрибуты типа string.

## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

```python
class MyClass:
        def __init__(self, value):
            self._value = value

        def set_value(self, value):
            self._value = value

        def get_value(self):
            return self._value

        def del_value(self):
            del self._value

        value = property(get_value, set_value, del_value, "Свойство value")

obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/3t9.png)

## Выводы
Этот код создает класс MyClass с атрибутом _value и свойством value, которое управляет доступом к этому атрибуту через методы get_value, set_value и del_value. Это свойство позволяет получать, устанавливать и удалять значение _value с помощью property. Ошибка возникает в последней строке print(obj.get_value()), потому что после вызова obj.del_value() атрибут _value был удален. Попытка его чтения приводит к ошибке AttributeError, так как атрибут больше не существует.
  
## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    className = 'Mammal'


class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")

```

### Результат

![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/4t9.png)
## Выводы
Этот код создает базовый класс Mammal и два подкласса Dog и Cat, которые наследуют от Mammal. Этот код выводит информацию о каждом из объектов dog и cat, используя их свойства.
## Лабораторная работа №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

```python
class Russian:

    @staticmethod
    def greeting():
        print("Привет")

class English:

    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/5t9.png)

## Выводы
Этот код создает два класса Russian и English, каждый из которых имеет статический метод greeting, выводящий приветствие на соответствующем языке.

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться от тех, что указаны в методичке и лабораторных заданиях.
```python
  
```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/6t9.png)
## Выводы
В данной задаче был создан класс Animal с двумя атрибутами: species (вид) и age (возраст). Объект dog был создан на основе этого класса, и его атрибуты были успешно выведены в консоль. Это задание помогает понять основы создания классов и объектов в Python.

## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса.
```python
 
```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/7t9.png)
## Выводы

Здесь класс Animal был дополнен методом make_sound, который выводит сообщение о звуке, издаваемом животным. Это задание показало, как добавлять методы к классу для выполнения определенных действий.

## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом.
```python

```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/8t9.png)
## Выводы
Здесь был создан подкласс Dog, который наследует класс Animal. В классе Dog добавлен метод bark, который выводит сообщение "Woof!". Это задание показало, как использовать наследование для создания более специфичных классов на основе более общих.

## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом.
```python

```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/9t9.png)

## Выводы

Здесь был реализован механизм инкапсуляции для атрибута age класса Animal, делая его приватным. Метод get_age предоставляет доступ к значению, а метод set_age позволяет изменять его с проверкой. Это задание демонстрирует принцип инкапсуляции, который помогает защитить данные внутри класса.

## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться от примеров в методичке.
```python
 
```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/10t9.png)
## Выводы
Здесь был продемонстрирован полиморфизм. Классы Dog и Cat переопределили метод make_sound класса Animal, каждый со своим собственным звуком. Полиморфизм позволяет вызывать один и тот же метод для различных объектов, обеспечивая гибкость и расширяемость кода.

## Общий вывод 
Концепции и принципы объектно-ориентированного программирования (ООП) играют ключевую роль в современном программировании, обеспечивая модульность, гибкость и повторное использование кода. В Python объектно-ориентированное программирование (ООП) реализовано гибко и просто, что позволяет эффективно применять его основные принципы: инкапсуляцию, наследование, полиморфизм и абстракцию.
