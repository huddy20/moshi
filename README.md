# Тема 8. Введение в ООП 
Отчет по Теме #8 выполнил(а):
- Холкин Данил Алексеевич
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.
```python
class Car:
    # Конструктор класса, инициализирующий атрибуты make и model
    def __init__(self, make, model):
        self.make = make  # Устанавливаем марку автомобиля
        self.model = model  # Устанавливаем модель автомобиля

# Создаем объект my_car класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/1t8.png)

## Выводы
Создание класса Car с конструктором инициализирующим атрибуты make и model. Создание объекта my_car класса Car с маркой "Toyota" и моделью "Corolla".

## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
```python
class Car:
    # Конструктор класса, который инициализирует атрибуты make и model
    def __init__(self, make, model):
        self.make = make  # Устанавливаем марку автомобиля
        self.model = model  # Устанавливаем модель автомобиля

    # Метод для запуска действия "водить" автомобиля
    def drive(self):
        # Выводит сообщение о вождении автомобиля с указанием марки и модели
        print(f"Driving the {self.make} {self.model}")

# Создаем объект my_car класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
# Вызываем метод drive для my_car, что выведет сообщение о вождении
my_car.drive()

```
### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/2t8.png)

## Выводы
Создание класса Car с конструктором инициализирующим атрибуты make и model. Создание метода drive, который выводит сообщение в консоль. Создаем объект my_car класса Car. Вызываем метод drive для my_car.

## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car:
    # Конструктор класса, который инициализирует атрибуты make и model
    def __init__(self, make, model):
        self.make = make  # Устанавливаем марку автомобиля
        self.model = model  # Устанавливаем модель автомобиля

    # Метод для запуска действия "водить" автомобиля
    def drive(self):
        # Выводит сообщение о вождении автомобиля с указанием марки и модели
        print(f"Driving the {self.make} {self.model}")


# Создаем объект my_car класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
# Вызываем метод drive для my_car, что выведет сообщение о вождении
my_car.drive()


class ElectricCar(Car):
    # Конструктор класса ElectricCar, наследуемого от Car, и инициализация атрибута батареи
    def __init__(self, make, model, battery_capacity):
        # Вызов конструктора базового класса Car для установки make и model
        super().__init__(make, model)
        self.battery_capacity = battery_capacity  # Устанавливаем емкость батареи

    # Метод для запуска действия "зарядки" электромобиля
    def charge(self):
        # Выводит сообщение о зарядке автомобиля с указанием емкости батареи
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")


# Создаем объект my_electric_car класса ElectricCar с маркой "Tesla", моделью "Model S" и емкостью батареи 75 кВт⋅ч
my_electric_car = ElectricCar('Tesla', 'Model S', 75)
# Вызываем метод drive для my_electric_car, что выведет сообщение о вождении
my_electric_car.drive()
# Вызываем метод charge для my_electric_car, что выведет сообщение о зарядке
my_electric_car.charge()

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/3t8.png)

## Выводы
Создаем класс ElectricCar, наследуемого от Car, и инициализация атрибута батареи. Создаем метод charge для зарядки батареи. Создаем объект my_electric_car класса ElectricCar с маркой "Tesla", моделью "Model S" и емкостью батареи 75 кВт⋅ч. Вызываем метод drive для my_electric_car, что выведет сообщение о вождении. Вызываем метод charge для my_electric_car, что выведет сообщение о зарядке.
  
## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
```python
class Car:
    # Конструктор класса, который инициализирует атрибуты _make и __model
    def __init__(self, make, model):
        self._make = make  # Полузакрытый атрибут _make (может использоваться вне класса, но рекомендуется использовать внутри)
        self.__model = model  # Закрытый атрибут __model (может использоваться только внутри класса)

    # Метод для запуска действия "водить" автомобиля
    def drive(self):
        # Выводит сообщение о вождении автомобиля с указанием марки и модели
        print(f"Driving the {self._make} {self.__model}")


# Создаем объект my_car класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
# Выводим значение полузакрытого атрибута _make объекта my_car
print(my_car._make)
# Вызываем метод drive для my_car, что выведет сообщение о вождении
my_car.drive()

```

### Результат

![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/4t8.png)
## Выводы
self._make: полузакрытый атрибут, к которому можно обратиться извне, хотя предпочтительно использовать его только внутри класса.
self.__model: закрытый атрибут, доступ к которому возможен только внутри класса, благодаря двойному подчеркиванию.

## Лабораторная работа №5
### Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
```python
# Определяем базовый класс "Shape" с методом area, который будет переопределяться в дочерних классах
class Shape:
    # Метод для расчета площади фигуры; базовый метод не выполняет действий
    def area(self):
        pass


# Определяем класс "Rectangle", наследуемый от "Shape", для представления прямоугольника
class Rectangle(Shape):
    # Конструктор класса, инициализирующий ширину и высоту прямоугольника
    def __init__(self, width, height):
        self.width = width  # Устанавливаем ширину
        self.height = height  # Устанавливаем высоту

    # Переопределенный метод для расчета площади прямоугольника
    def area(self):
        return self.width * self.height  # Площадь прямоугольника = ширина * высота


# Определяем класс "Circle", наследуемый от "Shape", для представления круга
class Circle(Shape):
    # Конструктор класса, инициализирующий радиус круга
    def __init__(self, radius):
        self.radius = radius  # Устанавливаем радиус

    # Переопределенный метод для расчета площади круга
    def area(self):
        return 3.14 * self.radius * self.radius  # Площадь круга = π * радиус^2


# Создаем массив (список) с экземплярами фигур: круг и прямоугольник
shapes = [
    Rectangle(4, 5),  # Прямоугольник с шириной 4 и высотой 5
    Circle(3)         # Круг с радиусом 3
]

# Проходим циклом по массиву фигур и выводим площади для каждой фигуры
for shape in shapes:
    print(shape.area())  # Вызываем метод area для каждого объекта в списке

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/5t8.png)

## Выводы
Ищем площади фигур

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться от тех, что указаны в методичке и лабораторных заданиях.
```python
  class Animal:
      def __init__(self, species, age):
          self.species = species
          self.age = age
  
  dog = Animal("Dog", 5)
  print(f"Species: {dog.species}, Age: {dog.age}")
```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/6t8.png)
## Выводы
В данной задаче был создан класс Animal с двумя атрибутами: species (вид) и age (возраст). Объект dog был создан на основе этого класса, и его атрибуты были успешно выведены в консоль. Это задание помогает понять основы создания классов и объектов в Python.

## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса.
```python
  class Animal:
      def __init__(self, species, age):
          self.species = species
          self.age = age
    
      def make_sound(self):
          print(f"The {self.species} makes a sound.")

  dog = Animal("Dog", 5)
  dog.make_sound()
```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/7t8.png)
## Выводы

Здесь класс Animal был дополнен методом make_sound, который выводит сообщение о звуке, издаваемом животным. Это задание показало, как добавлять методы к классу для выполнения определенных действий.

## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом.
```python
  class Animal:
      def __init__(self, species, age):
          self.species = species
          self.age = age
  
      def make_sound(self):
          print(f"The {self.species} makes a sound.")
  
  class Dog(Animal):
      def __init__(self, age, breed):
          super().__init__("Dog", age)
          self.breed = breed
      
      def bark(self):
          print("Woof!")
  
  labrador = Dog(3, "Labrador")
  labrador.make_sound()
  labrador.bark()
```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/8t8.png)
## Выводы
Здесь был создан подкласс Dog, который наследует класс Animal. В классе Dog добавлен метод bark, который выводит сообщение "Woof!". Это задание показало, как использовать наследование для создания более специфичных классов на основе более общих.

## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом.
```python
  class Animal:
      def __init__(self, species, age):
          self.species = species
          self.__age = age  # Инкапсуляция атрибута age
      
      def get_age(self):
          return self.__age
      
      def set_age(self, age):
          if age >= 0:
              self.__age = age
          else:
              print("Invalid age")
  
  dog = Animal("Dog", 5)
  print(dog.get_age())
  dog.set_age(6)
  print(dog.get_age())
  dog.set_age(-1)  # Неправильный возраст
```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/9t8.png)

## Выводы

Здесь был реализован механизм инкапсуляции для атрибута age класса Animal, делая его приватным. Метод get_age предоставляет доступ к значению, а метод set_age позволяет изменять его с проверкой. Это задание демонстрирует принцип инкапсуляции, который помогает защитить данные внутри класса.

## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться от примеров в методичке.
```python
  class Animal:
      def make_sound(self):
          print("Some generic animal sound")
  
  class Dog(Animal):
      def make_sound(self):
          print("Woof!")
  
  class Cat(Animal):
      def make_sound(self):
          print("Meow!")

  animals = [Dog(), Cat(), Animal()]
  
  for animal in animals:
      animal.make_sound()
```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/10t8.png)
## Выводы
Здесь был продемонстрирован полиморфизм. Классы Dog и Cat переопределили метод make_sound класса Animal, каждый со своим собственным звуком. Полиморфизм позволяет вызывать один и тот же метод для различных объектов, обеспечивая гибкость и расширяемость кода.

## Общий вывод 
В ходе выполнения этих заданий были изучены основные принципы объектно-ориентированного программирования (ООП): создание классов и объектов, работа с атрибутами и методами, наследование, инкапсуляция и полиморфизм. Эти задания помогли глубже понять концепции ООП, что является важным аспектом структурирования кода и создания более гибких, масштабируемых программ.
