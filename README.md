# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил(а):
- Холкин Данил Алексеевич
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.

```python
from functools import lru_cache

@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == '__main__':
    print(fibonacci(100))

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/1t10.png)
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/1.1t10.png)

## Выводы
На первом скриншоте работа без декоратора, очень долгое вычисление. На втором с декоратором, мгновенный вывод. 

## Лабораторная работа №2
### Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130.

```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func

@check
def personal_info(name, age):
    print(f"Name: {name}, Age: {age}")

if __name__ == '__main__':
    personal_info('Владимир', 18)
    personal_info('Александр', -10)
    personal_info('Петр', 138, 12, 42, 2)

```
### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/2t10.png)

## Выводы
Декоратор для функции принимающей возраст и имя, которая проверяет, чтобы возраст был больше 0 и меньше 130.

## Лабораторная работа №3
### Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string. Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт. Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.

```python
def data(*args):
    try:
        for i in range(0,len(args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

if __name__ == '__main__':
    data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/3t10.png)

## Выводы
Этот код выполняет следующие действия:
Принимает произвольное количество аргументов через *args. Предполагает, что первый аргумент (args[0]) — это список. Перебирает элементы первого аргумента, пытается умножить каждый элемент на 15 и разделить на 10. Если возникает ошибка, она обрабатывается и выводится сообщение об ошибке. В блоке finally выводит сообщение "Вся информация обработана".

## Лабораторная работа №4
### Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация”

```python
class NegativeValueException(Exception):
    pass



def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')

if __name__ == '__main__':
    name = '12345678901'
    check_name(name)

```

### Результат

![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/4t10.png)
## Выводы
Код проверяет длину строки name, и если она превышает 10 символов, выбрасывает пользовательское исключение NegativeValueException, иначе выводит сообщение об успешной регистрации.

## Лабораторная работа №5
### После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции: init() (вызывается при создании класса декоратора в программе) и call() (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.

```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного подключения')


@SiteChecker
def site():
    print('Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/5t10.png)

## Выводы
Код использует декоратор SiteChecker для проверки перед и после выполнения функции site, добавляя дополнительные сообщения при запуске и завершении работы сайта.

## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор.
```python
import time  # Импортируем модуль time для работы с временем

# Декоратор для замера времени выполнения функции
def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Засекаем время начала
        result = func(*args, **kwargs)  # Выполняем функцию
        end_time = time.time()  # Засекаем время окончания
        print(f"\nВремя выполнения функции {func.__name__}: {end_time - start_time:.5f} секунд")  # Выводим затраченное время
        return result
    return wrapper

# Функция для расчета чисел Фибоначчи
@measure_time
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')

# Точка входа
if __name__ == '__main__':
    fibonacci()  # Запускаем функцию

```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/6t10.png)
## Выводы
Код вычисляет числа Фибоначчи от 2 до 200, выводит их в строку и сообщает время выполнения функции.

## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.

```python
# Открытие файла с проверкой его содержимого
def read_file(file_path):
    try:
        # Открываем файл в режиме чтения
        with open(file_path, 'r') as file:
            content = file.read()  # Считываем содержимое файла
            if not content:  # Проверяем, если файл пустой
                raise ValueError("Файл пустой")  # Бросаем исключение, если содержимое пусто
            print("Содержимое файла:")
            print(content)  # Выводим содержимое файла
    except FileNotFoundError:
        # Обрабатываем случай, если файл не найден
        print("Ошибка: Файл не найден")
    except ValueError as e:
        # Обрабатываем выброшенное исключение пустого файла
        print(f"Ошибка: {e}")
    except Exception as e:
        # Общий случай обработки других исключений
        print(f"Произошла неожиданная ошибка: {e}")

# Точка входа
if __name__ == "__main__":
    # Указываем пути к файлам
    empty_file = "empty.txt"  # Пустой файл
    non_empty_file = "non_empty.txt"  # Файл с данными
    
    # Создаем пустой файл
    with open(empty_file, 'w') as file:
        pass  # Ничего не пишем, файл остается пустым
    
    # Создаем файл с данными
    with open(non_empty_file, 'w') as file:
        file.write("Это тестовая строка.\nЭтот файл не пустой!")  # Записываем данные
    
    # Читаем пустой файл
    print("Попытка чтения пустого файла:")
    read_file(empty_file)
    
    # Читаем файл с данными
    print("\nПопытка чтения файла с данными:")
    read_file(non_empty_file)


```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/7t10.png)
## Выводы
Код создает пустой и непустой файлы, обрабатывает чтение файла с проверкой на пустоту, и если файл пустой, выводит "Файл пустой", иначе отображает его содержимое.

## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль
```python
# Функция, которая складывает 2 и введенное пользователем число
def add_two_to_user_input():
    try:
        # Запрашиваем ввод числа у пользователя
        user_input = input("Введите число: ")
        number = float(user_input)  # Преобразуем введенное значение в число
        result = 2 + number  # Складываем 2 и число
        print(f"Результат: {result}")  # Выводим результат
    except ValueError:
        # Обрабатываем ошибку преобразования строки в число
        print("Неподходящий тип данных. Ожидалось число.")


# Точка входа
if __name__ == "__main__":
    # Тесты функции
    print("Тест 1: Корректный ввод числа '10'")
    add_two_to_user_input()  # Введите: 10

    print("\nТест 2: Некорректный ввод строки 'abc'")
    add_two_to_user_input()  # Введите: abc

    print("\nТест 3: Ввод числа с плавающей точкой '5.5'")
    add_two_to_user_input()  # Введите: 5.5

    print("\nТест 4: Некорректный ввод символа '#'")
    add_two_to_user_input()  # Введите: #


```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/8t10.png)
## Выводы
Код запрашивает ввод числа у пользователя, добавляет к нему 2 и выводит результат; если ввод некорректный (например, строка или символ), выводится сообщение об ошибке с использованием исключения ValueError.

## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
```python
# Определяем декоратор как класс
class RepeatDecorator:
    def __init__(self, func):
        self.func = func  # Сохраняем функцию, которая декорируется

    def __call__(self, *args, **kwargs):
        print(f"Выполнение функции '{self.func.__name__}' дважды:")  # Сообщаем, что функция будет выполнена дважды
        self.func(*args, **kwargs)  # Первый вызов функции
        self.func(*args, **kwargs)  # Второй вызов функции


# Декорируемая функция 1: выводит приветствие
@RepeatDecorator
def greet():
    print("Привет! Добро пожаловать!")


# Декорируемая функция 2: считает сумму двух чисел
@RepeatDecorator
def add_numbers(a, b):
    print(f"Сумма чисел {a} и {b} равна {a + b}")


# Точка входа
if __name__ == "__main__":
    print("Тест 1: Функция greet()")
    greet()  # Функция выполнится дважды

    print("\nТест 2: Функция add_numbers(3, 5)")
    add_numbers(3, 5)  # Функция выполнится дважды


```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/9t10.png)
## Выводы
Класс RepeatDecorator:
Декоратор реализован как класс, сохраняющий ссылку на переданную функцию. Метод call делает декорируемую функцию вызываемой, выполняя её дважды.
Первая функция greet:
Приветствует пользователя. При декорировании выполняется дважды.
Вторая функция add_numbers:
Принимает два числа, вычисляет их сумму и выводит результат. Выполняется дважды из-за использования декоратора.
Тесты:
Тест 1 вызывает функцию greet, результат — два приветствия. Тест 2 вызывает функцию add_numbers(3, 5), результат — дважды выводится сумма чисел.
Общий вывод:
Код реализует декоратор, который дважды выполняет декорируемую функцию. Это применимо как к функциям без параметров, так и к функциям с аргументами, как продемонстрировано в тестах.

## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
```python
# Определяем собственное исключение
class NegativeNumberError(Exception):
    """Исключение выбрасывается, если передано отрицательное число."""
    pass


# Первая функция: проверяет, является ли число положительным
def check_positive_number(num):
    try:
        if num < 0:  # Если число отрицательное
            raise NegativeNumberError(f"Число {num} является отрицательным")  # Бросаем исключение
        print(f"Число {num} положительное")  # Если всё в порядке
    except NegativeNumberError as e:
        print(f"Ошибка: {e}")  # Обрабатываем наше собственное исключение


# Вторая функция: вычисляет квадратный корень числа
import math


def calculate_square_root(num):
    try:
        if num < 0:  # Проверяем, если число отрицательное
            raise NegativeNumberError(
                f"Невозможно вычислить корень из отрицательного числа: {num}")  # Бросаем исключение
        result = math.sqrt(num)  # Вычисляем корень
        print(f"Квадратный корень числа {num} равен {result:.2f}")
    except NegativeNumberError as e:
        print(f"Ошибка: {e}")  # Обрабатываем наше исключение


# Точка входа
if __name__ == "__main__":
    # Тест 1: Проверяем положительное и отрицательное число
    print("Тест 1: Функция check_positive_number()")
    check_positive_number(10)  # Положительное число
    check_positive_number(-5)  # Отрицательное число

    # Тест 2: Пытаемся вычислить квадратный корень
    print("\nТест 2: Функция calculate_square_root()")
    calculate_square_root(16)  # Положительное число
    calculate_square_root(-9)  # Отрицательное число


```

### Результат.
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/10t10.png)
## Выводы
Класс NegativeNumberError:
Создано пользовательское исключение, чтобы обрабатывать случаи с отрицательными числами. Исключение содержит сообщение, которое указывает, почему оно выбрасывается.
Первая функция check_positive_number:
Проверяет, является ли переданное число положительным. Если число отрицательное, выбрасывает NegativeNumberError.
Вторая функция calculate_square_root:
Пытается вычислить квадратный корень числа. Если число отрицательное, выбрасывает NegativeNumberError, чтобы предупредить о невозможности вычисления.
Тесты:
Тест 1 проверяет, как check_positive_number обрабатывает положительные и отрицательные числа. Тест 2 показывает, как calculate_square_root вычисляет корень из положительных чисел и обрабатывает отрицательные числа с помощью исключения.
Общий вывод:
Код определяет пользовательское исключение NegativeNumberError для обработки случаев с отрицательными числами, которое используется в двух разных функциях для проверки числа и вычисления квадратного корня. Это помогает улучшить читаемость и повторное использование обработки ошибок.
## Общий вывод 
Декораторы и исключения в Python — это мощные инструменты, которые повышают гибкость и надежность кода. Декораторы позволяют модифицировать или оборачивать функции без изменения их исходного кода, что делает их удобными для добавления повторяющегося функционала, например, логирования, проверки прав доступа или измерения времени выполнения. Исключения, в свою очередь, помогают обрабатывать ошибки и нестандартные ситуации, делая программы более устойчивыми к сбоям. Совместное использование этих инструментов способствует написанию структурированного, читаемого и безопасного кода.
